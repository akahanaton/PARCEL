from snakemake.utils import R
from os.path import join
import csv

# simulate a bash login shell, see https://bitbucket.org/johanneskoester/snakemake/wiki/FAQ
shell.executable("/bin/bash")
#
# # "unofficial bash strict mode" http://www.redsymbol.net/articles/unofficial-bash-strict-mode/
shell.prefix("source ~/.bashrc; set -euo pipefail;")
#
#

# Globals ---------------------------------------------------------------------

# get the seqbatch : libid pairs for given comparebatch id
LIBIDS = []
SEQBATCHS = []
SEQDIR = []
SEQFILES = []
TREATMENTS = []
sampleinfo = open(config["SAMPLEINFO"],"r",newline='')
for line in sampleinfo:
	allelems = line.strip().split("\t");
	if allelems[6] == config["COMPAREBATCH"]:
		LIBIDS.append(allelems[1])
		SEQBATCHS.append(allelems[4])
		SEQDIR.append(allelems[8])
		SEQFILES.append(allelems[8] + allelems[7])
		if allelems[2] != config["CONTROL"]:
			TREATMENTS.append(allelems[2])

TREATMENTS = list(set(TREATMENTS))

#print(LIBIDS)
#print(SEQBATCHS)

# get condition and id pair
CONDITIONS = {}
sampleinfo = open(config["SAMPLEINFO"],"r",newline='')
for line in sampleinfo:
	CONDITIONS[line.split("\t")[1]] = line.split("\t")[2]


###################################################################################
# for calling differential sites
###################################################################################

OUTPUTDIRCOV = {
 "AUTOBATCH": {
    "T": "Batch",
    "F": "NoBatch"
 },
 "VSALL": {
    "T": "vsAll",
    "F": "onlyControl"
 },
}
# the merged coverage files
MERGEDCOVDIR = config["PARCELDIR"] + "/mergedCov/" + config["COMPAREBATCH"] + "/"

RESULTDIR = config["PARCELDIR"] + config["COMPAREBATCH"] + "/"

#GENEDIFFPRE = config["PARCELDIR"] + "Gene_" + {wildcards.treatment}
#GENEDIFFDIR = GENEDIFFPRE + "_" + SUFFIX + "/"
#
#FILTERPRE = config["PARCELDIR"] + "Filter_" + {wildcards.treatment} + "_" + config["TOPCOV"] 
#FILTERDIR = FILTERPRE + "_" + SUFFIX + "_" + config["EVALUECUT"] + "_" + config["WFC"] + "/"


# define function to convert id to sample name


#getSampleInfo <- function(configfile,id,querykey) {
#	mydata = read.table(configfile,header=T,sep="\t");
#	result = mydata[mydata[,"LibID"]==id,querykey];
#	return(result);
#    # R code
#}
#
#

# snakemake -np  -s cutadaptor.sk --configfile conf-cutadaptor.json  --dag |  dot -Tsvg > dag.svg

def get_bedgraph_files(wc):
	return [config["BEDGRAPHDIR"] + config["COMPAREBATCH"] + "/" + CONDITIONS[LIBIDS[k]] + '_{}'.format(LIBIDS[k]) + '_{}_nor.bedgraph.gz'.format(SEQBATCHS[k]) for k in range(len(LIBIDS))]

rule final:
	input: 
		#expand("/home/sheny/prog/parcel/Yeast/Fastq/MUX3857/{id}.fastq.gz", zip, id=LIBIDS, seqbatch=SEQBATCHS)
		#expand(config["TRIMDIR"] + '{id}.trim.fastq', zip, id=LIBIDS, seqbatch=SEQBATCHS)
		#expand(config["TRIMDIR"] + 'read.trim.{id}.log.sum', zip, id=LIBIDS, seqbatch=SEQBATCHS)
		#expand(config["TRIMDIR"] + 'read.trim.{id}.log', zip, id=LIBIDS, seqbatch=SEQBATCHS)
		#expand(config["MAPBAMS"] + '{id}.trim.fastq.genome_mapping_best_sort.bam', zip, id=LIBIDS, seqbatch=SEQBATCHS),
		#config["TRIMDIR"] + "trimSummary.txt",
		#config["MAPBAMS"] + "mapSummary.txt",
		#expand(config["TRIMDIR"] + "{seqbatch}/" + "read.trim.{id}.log.sum", zip, seqbatch = SEQBATCHS, id = LIBIDS),
		#config["TABDIR"] + config["COMPAREBATCH"] + "/" + "allcov.wide.min" + config["COVMIN"] + ".txt.gz",
		#config["TABDIR"] + config["COMPAREBATCH"] + "/" + "allgenecov.wide" + ".txt.gz",
		config["QUALCHECKDIR"] + config["COMPAREBATCH"] + "/" + "processingSummary.xls",
		expand(config["PARCELDIR"] + config["COMPAREBATCH"] + "/" + "combined_{treatment}_output2_wfilters.txt",treatment = TREATMENTS),
		expand(config["PARCELDIR"] + config["COMPAREBATCH"] + "/" + "combined_{treatment}_output2_wfilters.bed",treatment = TREATMENTS),
		expand(config["PARCELDIR"] + config["COMPAREBATCH"] + "/" + "{treatment}_covplot/sigRegion.xls",treatment = TREATMENTS),
		expand(config["PARCELDIR"] + config["COMPAREBATCH"] + "/" + "{treatment}_covplot/sigRegion.highlightSeq.xls",treatment = TREATMENTS)
		#expand(RESULTDIR + "Filter_" + '{treatment}' + "_" + config["TOPCOV"] + "_" + config["COMPAREBATCH"] + "_" + config["CONTROL"] + "_" + '{treatment}' + "_" + OUTPUTDIRCOV["AUTOBATCH"][config["AUTOBATCH"]] + "_" + OUTPUTDIRCOV["VSALL"][config["VSALL"]] + "_" + config["COVMIN"] + "_" + config["EVALUECUT"] + "_" + config["WFC"] + "/covplot/" + "sigRegion.xls", treatment = TREATMENTS),
		#expand(RESULTDIR + "Site_" + '{treatment}' + "_" + config["TOPCOV"] + "_" + config["COMPAREBATCH"] + "_" + config["CONTROL"] + "_" + '{treatment}' + "_" + OUTPUTDIRCOV["AUTOBATCH"][config["AUTOBATCH"]] + "_" + OUTPUTDIRCOV["VSALL"][config["VSALL"]] + "_" + config["COVMIN"] + "/" + "sigRegion.bed", treatment = TREATMENTS),
		#expand(RESULTDIR + "Gene_" + '{treatment}' + "_" + config["COMPAREBATCH"] + "_" + config["CONTROL"] + "_" + '{treatment}' + "_" + OUTPUTDIRCOV["AUTOBATCH"][config["AUTOBATCH"]] + "_" + OUTPUTDIRCOV["VSALL"][config["VSALL"]] + "_" + config["COVMIN"] + "/" + "geneDiff.txt", treatment = TREATMENTS),
		#get_bedgraph_files
		#config["TABDIR"] + "allcov.wide.min100" + ".txt.gz",
		#condition = lambda wildcards: CONDITIONS[wildcards.id],
		#expand(config["BEDGRAPHDIR"] + CONDITIONS[{id}] + '_{id}.bedgraph.gz', zip, zip, id=LIBIDS, seqbatch=SEQBATCHS)
		#expand(config["BEDGRAPHDIR"] + CONDITIONS.get("{id}") + '_{id}.bedgraph.gz', zip, id=LIBIDS, seqbatch=SEQBATCHS)
		#expand(config["BEDGRAPHDIR"] + '{id}.bedgraph.gz',zip, id=LIBIDS, seqbatch=SEQBATCHS)
		#config["BEDGRAPHDIR"] + '{id}.bedgraph.gz'
		#"./test.txt"

rule trimAdaptor:
	input: 
		config["INPUTDIR"] + "{seqbatch}/" + "{id}.fastq.gz"
		#get_input_files
	output: 
		trimseq = config["TRIMDIR"] + "{seqbatch}/" + "{id}.trim.fastq.gz",
		trimseqTemp = temp(config["TRIMDIR"] + "{seqbatch}/" + "{id}.trim.fastq"),
		trimlog = config["TRIMDIR"] + "{seqbatch}/" + "read.trim.{id}.log",
		trimsum = config["TRIMDIR"] + "{seqbatch}/" + "read.trim.{id}.log.sum"
	params:
		adp1={config["ADAPTER"]["A"]}, adp2={config["ADAPTER"]["B"]}

	log: config["TRIMDIR"] + "{seqbatch}/" + "/read.trim.{id}.err"
	threads: 16
	shell:
			#{config[CUTADPT]} -a AP1={params.adp1} -g AP2={params.adp2} -n 2 -O 5 -y 'FOUND__{{name}}__' -m 20 -o {output.trimseqTemp} {input} > {output.trimlog} 
		"""
			bash {config[CUTADPT]} {input} {output.trimseqTemp} {params.adp1} {params.adp2} {threads} {output.trimlog}
			ID={wildcards.id} perl {config[PARSE_CUT_ADT]} {output.trimlog} > {output.trimsum}
			pigz -c -p {threads} {output.trimseqTemp} > {output.trimseq}
		"""


rule collectAdpTrimLog:
	input:
		expand(config["TRIMDIR"] + "{seqbatch}/" + 'read.trim.{id}.log.sum', zip, id=LIBIDS, seqbatch=SEQBATCHS)
	output:
		config["TRIMDIR"] + config["COMPAREBATCH"] + "/" + "trimSummary.txt"
	shell:
		"""
			cat {input} > {output}
		"""

rule mapToGenome:
	input:
		rules.trimAdaptor.output.trimseq
	output:
		bamresult = config["MAPBAMS"] + "{seqbatch}/" + "{id}.trim.fastq.genome_mapping_best.sort.bam",
		bamresultTmp = temp(config["MAPBAMS"] + "{seqbatch}/" + "{id}.trim.fastq.genome_mapping_best.bam"),
		#bamindex = config["MAPBAMS"] + "{seqbatch}/" + "{id}.trim.fastq.genome_mapping_best_sort.bam.bai",
		maplog = config["MAPBAMS"] + "{seqbatch}/" + "{id}.trim.fastq.genome_mapping.log",
		logsum = config["MAPBAMS"] + "{seqbatch}/" + "{id}.trim.fastq.genome_mapping.summary"
		
	params:
		seqbatch = lambda wildcards: wildcards.seqbatch,
		mismatch = config["MISMATCH"],
		mapmodel = config["MAPMODEL"],
		genome = config["REFTRANSCRIPT"]
	threads: 12
	shell:
		"""
			MISMATCH={params.mismatch} sh {config[MAP_WAPPER]} {input} {threads} {params.genome} {output.maplog} {output.bamresultTmp}
			{config[SAMTOOLS]} sort -@ {threads} -T {wildcards.id} -m 1G -O BAM {output.bamresultTmp} > {output.bamresult}
			ID={wildcards.id} perl {config[SUM_MAPLOG]} {output.maplog} > {output.logsum}
		"""

#rule bedgraphTrack:
#	input:
#		bamresult = rules.mapToGenome.output.bamresult
#	output:
#		#config["BEDGRAPHDIR"] + CONDITIONS.get({id}) + '_{id}.bedgraph.gz'
#		#condition = lambda wildcards: CONDITIONS[wildcards.id]
#		#config["BEDGRAPHDIR"] + lamda wildcards: CONDITIONS[wildcards.id] + '_{id}.bedgraph.gz'
#		config["BEDGRAPHDIR"] + config["COMPAREBATCH"] + "/" + "{condition}_{id}_{seqbatch}_nor.bedgraph.gz"
#	params:
#		condition = lambda wildcards: CONDITIONS[wildcards.id]
#	shell:
#		"""
#			COVMIN=0 FIVEPOS=yes perl {config[TOBEDGRAPH]} {input.bamresult} {params.condition}_{wildcards.id}_nor {config[BEDGRAPH_SPE]} yes yes no | pigz -c -p 8 > {output}
#		"""

rule collectMapLog:
	input:
		expand(config["MAPBAMS"] + "{seqbatch}/" + '{id}.trim.fastq.genome_mapping.summary', zip, id=LIBIDS, seqbatch=SEQBATCHS)
	output:
		config["MAPBAMS"] + config["COMPAREBATCH"] + "/" + "mapSummary.txt"
	shell:
		"""
			cat {input} > {output}
		"""
rule qualityCheck:
	input:
		sampleinfo = config["SAMPLEINFO"],
		trimlog = rules.collectAdpTrimLog.output,
		maplog = rules.collectMapLog.output
	output:
		proSum = config["QUALCHECKDIR"] + config["COMPAREBATCH"] + "/" + "processingSummary.xls"
	params:
		outdir = config["QUALCHECKDIR"] + config["COMPAREBATCH"], batch = config["COMPAREBATCH"]
	shell:
		"""
			Rscript {config[QUALCHECKSCRIPT]} {input.sampleinfo} {input.trimlog} {input.maplog} {params.batch} {params.outdir}
		"""

rule coverageCount:
	input:
		bamresult = rules.mapToGenome.output.bamresult
	output:
		config["COVDIR"] + "{seqbatch}/" + "{id}.cov.txt.gz"
	threads: 4
	params: numhit = config["NUMHIT"]
	shell:
		"""
			NUMHIT={params.numhit} sh {config[BAMTOCOV]} {input.bamresult} {wildcards.id} {config[TRANSCRIPTOMESIZE]} | pigz -p {threads} -c > {output} 
		"""

rule collectCovCount:
	input:
		expand(config["COVDIR"] + "{seqbatch}/" + "{id}.cov.txt.gz", zip, id=LIBIDS, seqbatch=SEQBATCHS)
	output:
		MERGEDCOVDIR + "allcov.txt.gz"
	threads: 8
	shell:
		"""
			zcat {input} | pigz -p {threads} -c > {output}
		"""

rule reshapeCovCount:
	input:
		rules.collectCovCount.output
	output:
		MERGEDCOVDIR + "allcov.wide.min" + config["COVMIN"] + ".txt.gz"
	params:
		splitby = config["SPLITBY"], sampleinfo = config["SAMPLEINFO"],downprop = config["DOWNSAMPLEPROP"]
	threads: 1
	shell:
		"""
			Rscript {config[RESHAPETABLE]} -i {input} -o {output} -v V3 -f V1+V2~V4 --header F --filterbySum {config[COVMIN]} --splitBy {params.splitby} --sampleinfo {params.sampleinfo} --downSampleProp {params.downprop}
		"""


#IDFILE = config["TABDIR"] + config["COMPAREBATCH"] + "/" + "idlist.txt"

rule saveCovToRdata:
	input:
		rules.reshapeCovCount.output
	output:
		config["PARCELDIR"] + config["COMPAREBATCH"] + "/" + "combined_v1all.Rdata"
	threads: 8
	params: 
		outdir = config["PARCELDIR"] + config["COMPAREBATCH"] + "/", sampleinfo = config["SAMPLEINFO"], batchid = config["COMPAREBATCH"],ismerge = config["ISMERGE"]
	shell:
		"""
			Rscript {config[MERGETAB]} --args {params.outdir} {input} {params.sampleinfo} {params.batchid} {output} {params.ismerge}
		"""

rule calldiffsites:
	input:
		covfile = rules.saveCovToRdata.output 
	output: 
		pvaluefile = config["PARCELDIR"] + config["COMPAREBATCH"] + "/" + "etTable_{treatment}.Rdata",
		covfile = config["PARCELDIR"] + config["COMPAREBATCH"] + "/" + "covinfo_{treatment}.Rdata"
	params:
		outdir = rules.saveCovToRdata.params.outdir, mincov = config["COVMIN"], treatment = lambda wildcards: wildcards.treatment, sampleinfo = config["SAMPLEINFO"], ismerge = config["ISMERGE"],
		sffile = config["PARCELDIR"] + config["COMPAREBATCH"] + "/" + "edgeR_{treatment}_sf.Rdata", batchid = config["COMPAREBATCH"], control = config["CONTROL"], vsall = config["VSALL"]
	threads: 1
	shell:
		"""
			Rscript {config[RUNEDGER]} --args {params.outdir} {params.mincov} {params.treatment} {params.control} {params.vsall} {params.sampleinfo} {input.covfile} {params.sffile} {params.batchid} {params.ismerge}
		"""

rule getCandidateRegions:
	input:
		pvaluefile = rules.calldiffsites.output.pvaluefile,
		#tabfile = config["TABDIR"] + config["COMPAREBATCH"] + "/" + LIBIDS[1] + ".tab",
		covfile = rules.calldiffsites.output.covfile
	output:
		config["PARCELDIR"] + config["COMPAREBATCH"] + "/" + "fastq2_{treatment}_output10.Rdata"
	params:
		mincov = config["COVMIN"], treatment = lambda wildcards: wildcards.treatment, outdir = rules.saveCovToRdata.params.outdir,
		sffile = rules.calldiffsites.params.sffile
	shell:
		"""
			Rscript {config[REGIONEVALUE]} --args {params.mincov} {params.treatment} {params.outdir} {input.covfile}
		"""
		

rule filterCandidates:
	input:
		diffsitefile = rules.getCandidateRegions.output,
		covfile = rules.calldiffsites.output.covfile
	output:
		filtercands = config["PARCELDIR"] + config["COMPAREBATCH"] + "/" + "combined_{treatment}_output2_wfilters.txt",
	params:
		mincov = config["COVMIN"], treatment = lambda wildcards: wildcards.treatment, outdir = rules.saveCovToRdata.params.outdir, genestructure = config["GENESTRUC"],
		sffile = rules.calldiffsites.params.sffile, sampleinfo = config["SAMPLEINFO"], batchid = config["COMPAREBATCH"], ismerge = config["ISMERGE"]
	shell:
		"""
			Rscript {config[FILTERCANDS]} --args {params.mincov} {params.treatment} {params.outdir} {input.covfile} {params.sffile} {params.genestructure} {params.sampleinfo} {params.batchid} {params.ismerge}
		"""
rule convertToGenome:
	input:
		rules.filterCandidates.output.filtercands
	output:
		candbed = config["PARCELDIR"] + config["COMPAREBATCH"] + "/" + "combined_{treatment}_output2_wfilters.bed",
		candseq = temp(config["PARCELDIR"] + config["COMPAREBATCH"] + "/" + "combined_{treatment}_output2_wfilters.fa"),
	params:
		refTranscript = config["REFTRANSCRIPTFASTA"], refGenome = config["GENOMEFASTA"]
	shell:
		"""
			Rscript {config[CONVERTTOBED]} -i {input} -s {output.candseq} -o {output.candbed} -r {params.refTranscript} -g {params.refGenome}
		"""
	
rule coveragePlot:
	input:
		filtercands = rules.convertToGenome.output.candbed,
		siterawcov = config["RAWCOV"]
		
	output:
		sigregion = config["PARCELDIR"] + config["COMPAREBATCH"] + "/{treatment}_covplot/sigRegion.xls",
		sigregionHighlight = config["PARCELDIR"] + config["COMPAREBATCH"] + "/{treatment}_covplot/sigRegion.highlightSeq.xls",
		sequences = config["PARCELDIR"] + config["COMPAREBATCH"] + "/{treatment}_covplot/sequences.fas",
		ribocov = config["PARCELDIR"] + config["COMPAREBATCH"] + "/{treatment}_covplot/covinfo.xls"
		
	params:
		sampleinfo = config["SAMPLEINFO"], nrexonbed = config["GENEEXONBED"], treatment = lambda wildcards: wildcards.treatment, control = config["CONTROL"], 
		topcov = config["TOPCOV"], batch = config["COMPAREBATCH"], autobatch = config["AUTOBATCH"], genome = config["GENOMEFASTA"], cdsbed = config["CDSBED"],
		outdir = rules.filterCandidates.params.outdir + "{treatment}_covplot/", ismerge = config["ISMERGE"]
	threads: 16
	shell:
		"""
			Rscript {config[COVPLOT]} -o {params.outdir} -i {input.filtercands} -s {params.sampleinfo} -b {params.batch} -t {params.treatment} -c {params.control} --covfile {input.siterawcov} --genome {params.genome} --getFasta T --CDSBed {params.cdsbed} --genomeSize {config[GENOMESIZE]} --ismerge {params.ismerge}
			perl {config[HIGHLIGHTSEQ]} {output.sigregion} {output.sigregionHighlight}
		"""

